"""
ev_funcs
Python implementations of functions used with EvTAF and evsonganaly.m
"""

#from third-party
import numpy as np
from scipy.io import loadmat

#from hvc
import hvc.audio

def readrecf(filename):
    """
    reads .rec files output by EvTAF
    """

    rec_dict = {}
    with open(filename,'r') as recfile:
        line_tmp = ""
        while 1:
            if line_tmp == "":
                line = recfile.readline()
            else:
                line = line_tmp
                line_tmp = ""
                
            if line == "":  # if End Of File
                break
            elif line == "\n": # if blank line
                continue
            elif "Catch" in line:
                ind = line.find('=')
                rec_dict['iscatch'] = line[ind+1:]
            elif "Chans" in line:
                ind = line.find('=')
                rec_dict['num_channels'] = int(line[ind+1:])
            elif "ADFREQ" in line:
                ind = line.find('=')
                try:
                    rec_dict['sample_freq'] = int(line[ind+1:])
                except ValueError:
                    rec_dict['sample_freq'] = float(line[ind+1:])
            elif "Samples" in line:
                ind = line.find('=')
                rec_dict['num_samples'] = int(line[ind+1:])
            elif "T After" in line:
                ind = line.find('=')
                rec_dict['time_after'] = float(line[ind+1:])
            elif "T Before" in line:
                ind = line.find('=')
                rec_dict['time before'] = float(line[ind+1:])
            elif "Output Sound File" in line:
                ind = line.find('=')
                rec_dict['outfile'] = line[ind+1:]
            elif "Thresholds" in line:
                th_list = []
                while 1:
                    line = recfile.readline()
                    if line == "":
                        break
                    try:
                        th_list.append(float(line))
                    except ValueError:  # because we reached next section
                        line_tmp = line
                        break
                rec_dict['thresholds'] = th_list
                if line == "":
                    break
            elif "Feedback information" in line:
                fb_dict = {}
                while 1:
                    line = recfile.readline()
                    if line == "":
                        break
                    elif line == "\n":
                        continue
                    ind = line.find("msec")
                    time = float(line[:ind-1])
                    ind = line.find(":")
                    fb_type = line[ind+2:]
                    fb_dict[time] = fb_type
                rec_dict['feedback_info'] = fb_dict
                if line == "":
                    break
            elif "File created" in line:
                header = [line]
                for counter in range(4):
                    line = recfile.readline()
                    header.append(line)
                rec_dict['header']=header
    return rec_dict

def load_cbin(filename,channel=0):
    """
    loads .cbin files output by EvTAF. 
    
    arguments
    ---------
    filename : string

    channel : integer
        default is 0

    returns
    -------
    data : numpy array
        1-d vector of 16-bit signed integers

    sample_freq : integer
        sampling frequency in Hz. Typically 32000.
    """
    
    # .cbin files are big endian, 16 bit signed int, hence dtype=">i2" below
    data = np.fromfile(filename,dtype=">i2")
    recfile = filename[:-5] + '.rec'
    rec_dict = readrecf(recfile)
    data = data[channel::rec_dict['num_channels']]  # step by number of channels
    sample_freq = rec_dict['sample_freq']
    return data, sample_freq

def load_notmat(filename):
    """
    loads .not.mat files created by evsonganaly.m.
    wrapper around scipy.io.loadmat.
    Calls loadmat with squeeze_me=True to remove extra dimensions from arrays
    that loadmat parser sometimes adds.
    
    Argument
    --------
    filename : string, name of .not.mat file
     
    Returns
    -------
    notmat_dict : dictionary of variables from .not.mat files
    """

    if ".not.mat" in filename:
        pass
    elif filename[-4:] == "cbin":
            filename += ".not.mat"
    else:
        raise ValueError("Filename should have extension .cbin.not.mat or"
                         " .cbin")

    return loadmat(filename,squeeze_me=True)


def get_syls(cbin, spect_params, labels_to_use='all', syl_spect_width=-1):
    """
    Get birdsong syllables from .cbin files using the associated
    .cbin.not.mat file generated by evsonganaly.m (and the person that
    labeled the song).

    Parameters
    ----------
    cbin : string
        .cbin filename
    spect_params: dictionary
        with keys 'window_size','window_step','freq_cutoffs', and 'samp_freq'.
        Note that 'samp_freq' is the **expected** sampling frequency and the
        function throws an error if the actual sampling frequency of cbin does
        not match the expected one.
    labels_to_use : string
        String of all labels for which associated spectrogram should be made.
        E.g., if labels_to_use = 'iab' then syllables labeled 'i','a',or 'b'
        will be extracted and returned, but a syllable labeled 'x' would be
        ignored. If labels_to_use=='all' then all spectrograms are returned with
        empty strings for the labels. Default is 'all'.
    syl_spect_width : int
        Optional parameter to set constant width for each spectrogram of a
        syllable. Used for creating inputs to neural network where each input
        must be of a fixed size.
        Default value is -1; in this case, the width of the spectrogram will
        be the duration of the spectrogram as determined by the segmentation
        algorithm in evsonganaly.m, i.e. the onset and offset that are stored
        in the .cbin.not.mat file.
        If a different value is given, then the duration of each spectrogram
        will be that value, given in number of time bins in spectrogram.
        E.g., if 'syl_spect_width'==300 and a time bin is ~1 ms then each
        spectrogram will be 300 bins wide.

    Returns
    -------
    all_syl_spects : list of 2-d numpy arrays
        spectrogram
    all_syl_labels : list of chars
    """

    if labels_to_use != 'all':
        if type(labels_to_use) == str:
            labels_to_use = list(labels_to_use)
        else:
            ValueError('labels_to_use argument should be a string')

    all_syl_labels = []
    all_syl_spects = []
    dat, fs = load_cbin(cbin)
    if fs != spect_params['samp_freq']:
        raise ValueError(
            'Sampling frequency for {}, {}, does not match expected sampling '
            'frequency of {}'.format(cbin,
                                     fs,
                                     spect_params['samp_freq']))
    dat, fs = load_cbin(cbin)
    spect_obj = hvc.audio.make_spect(dat, fs, size=spect_params['window_size'],
                           step=spect_params['window_step'],
                           freq_cutoffs=spect_params['freq_cutoffs'])
    spect = spect_obj.spect
    time_bins = spect_obj.timeBins

    notmat = load_notmat(cbin)
    labels = notmat['labels']
    onsets = notmat['onsets'] / 1000.0
    offsets = notmat['offsets'] / 1000.0
    onsets_time_bins = [np.argmin(np.abs(time_bins - onset))
                        for onset in onsets]
    offsets_time_bins = [np.argmin(np.abs(time_bins - offset))
                         for offset in offsets]
    # extract each syllable, but include the "silence" around it
    for ind, label in enumerate(labels):
        if labels_to_use == 'all':
            label = None
        elif label not in labels_to_use:
            continue
        all_syl_labels.append(label)

        temp_syl_spect = spect[:, onsets_time_bins[ind]:offsets_time_bins[ind]]
        if syl_spect_width > 0:
            width_diff = syl_spect_width - temp_syl_spect.shape[1]
            # take half of difference between spects and make that the start index
            # so one half of 'empty' area will be on one side of spect
            # and the other half will be on other side
            # i.e., center the spectrogram
            left_width = int(round(width_diff / 2))
            right_width = width_diff - left_width
            if left_width > onsets_time_bins[ind]:
                left_width = onsets_time_bins[ind]
                right_width = width_diff - left_width
            elif offsets_time_bins[ind] + right_width > spect.shape[-1]:
                right_width = spect.shape[-1] - offsets_time_bins[ind]
                left_width = width_diff - right_width
            temp_syl_spect = spect[:, onsets_time_bins[ind] - left_width:
                             offsets_time_bins[ind] + right_width]
        all_syl_spects.append(temp_syl_spect)

    return all_syl_spects, all_syl_labels